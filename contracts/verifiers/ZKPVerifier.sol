// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "./base/BaseVerifier.sol";
import "../interfaces/IGroth16Verifier.sol";
import "../interfaces/IERC7857DataVerifier.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

contract ZKPVerifier is BaseVerifier, Ownable {

    address public preimageVerifier;
    address public transferVerifier;

    // Commitment -> RootHash
    mapping(uint256 => bytes32) public rootHashes;

    constructor(address _preimageVerifier, address _transferVerifier) Ownable(msg.sender) {
        preimageVerifier = _preimageVerifier;
        transferVerifier = _transferVerifier;
    }

    function setPreimageVerifier(address _preimageVerifier) external onlyOwner {
        preimageVerifier = _preimageVerifier;
    }
    function setTransferVerifier(address _transferVerifier) external onlyOwner {
        transferVerifier = _transferVerifier;
    }

    function setRootHash(uint256 _commitment, bytes32 _rootHash) external onlyOwner {
        rootHashes[_commitment] = _rootHash;
    }

    /// @notice Verify preimage of data, the _proof prove:
    ///         for public data, the proof is knowing the pre-image of dataHashes
    ///         for private data, the proof is knowing the pre-image of dataHashes and the plaintext of the pre-image
    ///         if preimage proof is not required, the proof is the data itself ✅
    /// @param proofs Proof generated by ZKP
    function verifyPreimage(
        bytes[] calldata proofs
    ) external view override returns (PreimageProofOutput[] memory) {
        PreimageProofOutput[] memory outputs = new PreimageProofOutput[](proofs.length);

        for (uint256 i = 0; i < proofs.length; i++) {
            bytes calldata proof = proofs[i];
            require(proof.length >= 456, "Invalid proof length");

            bytes32 dataHash   = bytes32(proof[0:32]);
            bytes calldata sealedKey = proof[32:136]; // 104 字节
            uint256 nonce      = uint256(bytes32(proof[136:168]));
            uint256 mac        = uint256(bytes32(proof[168:200]));

            uint256[2] memory a = [
                uint256(bytes32(proof[200:232])),
                uint256(bytes32(proof[232:264]))
            ];

            uint256[2][2] memory b = [
                [uint256(bytes32(proof[264:296])), uint256(bytes32(proof[296:328]))],
                [uint256(bytes32(proof[328:360])), uint256(bytes32(proof[360:392]))]
            ];

            uint256[2] memory c = [
                uint256(bytes32(proof[392:424])),
                uint256(bytes32(proof[424:456]))
            ];

//            bytes32 dataHash;
//            bytes sealedKey;
//            uint256 nonce;
//            uint256 mac;
//            uint256[2] memory a;
//            uint256[2][2] memory b;
//            uint256[2] memory c;
//
//            assembly {
//                // 直接从 calldata 按偏移读取
//                dataHash := calldataload(proof.offset)                      // 0..31
//                sealedKey := calldataload(add(proof.offset, 32))            // 32..47
//                nonce := calldataload(add(proof.offset, 48))                // 48..79
//                mac := calldataload(add(proof.offset, 80))                  // 80..111
//
//                mstore(a, calldataload(add(proof.offset, 112)))             // a[0] 112..143
//                mstore(add(a, 0x20), calldataload(add(proof.offset, 144)))  // a[1] 144..175
//
//                mstore(b, calldataload(add(proof.offset, 176)))
//                mstore(add(b, 0x20), calldataload(add(proof.offset, 208)))
//                mstore(add(b, 0x40), calldataload(add(proof.offset, 240)))
//                mstore(add(b, 0x60), calldataload(add(proof.offset, 272)))
//
//                mstore(c, calldataload(add(proof.offset, 304)))
//                mstore(add(c, 0x20), calldataload(add(proof.offset, 336)))
//            }

//            require(rootHashes[mac] == dataHash, "Root hash is not matched!");

            bool isValid = true;
            if (preimageVerifier != address(0)) {
                IGroth16Verifier verifier = IGroth16Verifier(preimageVerifier);

                uint256[2] memory publicInputs = [nonce, mac];

                isValid = verifier.verifyProof(a, b, c, publicInputs);
            }

            outputs[i] = PreimageProofOutput(dataHash, sealedKey, nonce, mac, a, b, c, preimageVerifier, isValid);
        }

        return outputs;
    }

    /// @notice Verify data transfer validity, the _proof prove:
    ///         1. The pre-image of oldDataHashes
    ///         2. The oldKey can decrypt the pre-image and the new key re-encrypt the plaintexts to new ciphertexts
    ///         3. The newKey is encrypted using the receiver's pubKey
    ///         4. The hashes of new ciphertexts is newDataHashes (key to note: ZKP does not support private key of the receiver, the new key is visible for sender)
    ///         5. The newDataHashes identified ciphertexts are available in the storage: need the signature from the receiver signing oldDataHashes and newDataHashes
    /// @param proofs Proof generated by ZKP
    function verifyTransferValidity(
        bytes[] calldata proofs
    ) external view override returns (TransferValidityProofOutput[] memory) {
        TransferValidityProofOutput[]
            memory outputs = new TransferValidityProofOutput[](proofs.length);

       for (uint256 i = 0; i < proofs.length; i++) {
            // 144 bytes for oldDataHashes, newDataHashes, pubKey, sealedKey, TODO: proofs payload
            require(proofs[i].length == 232, "Invalid proof length");

            bytes32 oldHash = bytes32(proofs[i][0:32]);
            bytes32 newHash = bytes32(proofs[i][32:64]);
            bytes memory pubKey = proofs[i][64:128];
            bytes calldata sealedKey = bytes(proofs[i][128:232]);

            // TODO: verify the proofs
            // 1. verify ZKP proof
            // 2. verify receiver's signature

            outputs[i] = TransferValidityProofOutput(
                oldHash,
                newHash,
                pubKey,
                sealedKey,
                true
            );
        }

        return outputs;
    }
}
