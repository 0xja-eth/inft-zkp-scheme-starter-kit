// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./base/BaseVerifier.sol";
import "../interfaces/IGroth16Verifier.sol";
import "../interfaces/IERC7857DataVerifier.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

contract ZKPVerifier is BaseVerifier, Ownable {

    address public preimageVerifier;
    address public transferVerifier;

    // Commitment -> RootHash
    mapping(uint256 => bytes32) public rootHashes;

    constructor(address _preimageVerifier, address _transferVerifier) Ownable(msg.sender) {
        preimageVerifier = _preimageVerifier;
        transferVerifier = _transferVerifier;
    }

    function setPreimageVerifier(address _preimageVerifier) external onlyOwner {
        preimageVerifier = _preimageVerifier;
    }
    function setTransferVerifier(address _transferVerifier) external onlyOwner {
        transferVerifier = _transferVerifier;
    }

    function setRootHash(uint256 _commitment, bytes32 _rootHash) external onlyOwner {
        rootHashes[_commitment] = _rootHash;
    }

    /// @notice Verify preimage of data, the _proof prove:
    ///         for public data, the proof is knowing the pre-image of dataHashes
    ///         for private data, the proof is knowing the pre-image of dataHashes and the plaintext of the pre-image
    ///         if preimage proof is not required, the proof is the data itself ✅
    /// @param proofs Proof generated by ZKP
    function verifyPreimage(
        bytes[] calldata proofs
    ) external view override returns (PreimageProofOutput[] memory) {
        PreimageProofOutput[] memory outputs = new PreimageProofOutput[](proofs.length);

        for (uint256 i = 0; i < proofs.length; i++) {
            bytes calldata proof = proofs[i];
            require(proof.length >= 368, "Invalid proof length");

            bytes32 dataHash;
            bytes16 sealedKey;
            uint256 nonce;
            uint256 mac;
            uint[2] memory a;
            uint[2][2] memory b;
            uint[2] memory c;

            // 使用 assembly 从 bytes 中按偏移量读取数据
            assembly {
                // bytes 数据的起始位置 = proof.offset
                let ptr := add(proof.offset, 0x20) // calldata 前 32 字节是 length

                dataHash := calldataload(proof.offset)             // 0 ~ 32
                sealedKey := calldataload(add(proof.offset, 32))   // 32 ~ 48
                nonce := calldataload(add(proof.offset, 48))       // 48 ~ 80
                mac := calldataload(add(proof.offset, 80))         // 80 ~ 112

                a_0 := calldataload(add(proof.offset, 112))
                a_1 := calldataload(add(proof.offset, 144))

                mstore(a, a_0)
                mstore(add(a, 0x20), a_1)

                mstore(b, calldataload(add(proof.offset, 176)))
                mstore(add(b, 0x20), calldataload(add(proof.offset, 208)))
                mstore(add(b, 0x40), calldataload(add(proof.offset, 240)))
                mstore(add(b, 0x60), calldataload(add(proof.offset, 272)))

                mstore(c, calldataload(add(proof.offset, 304)))
                mstore(add(c, 0x20), calldataload(add(proof.offset, 336)))
            }

            bool isValid = true;
            if (preimageVerifier != address(0)) {
                IGroth16Verifier verifier = IGroth16Verifier(preimageVerifier);

                uint[] memory publicInputs = new uint[](2);
                publicInputs[0] = nonce;
                publicInputs[1] = mac;

                isValid = verifier.verifyProof(a, b, c, publicInputs);
            }

            outputs[i] = PreimageProofOutput(dataHash, sealedKey, isValid);
        }

        return outputs;
    }

    /// @notice Verify data transfer validity, the _proof prove:
    ///         1. The pre-image of oldDataHashes
    ///         2. The oldKey can decrypt the pre-image and the new key re-encrypt the plaintexts to new ciphertexts
    ///         3. The newKey is encrypted using the receiver's pubKey
    ///         4. The hashes of new ciphertexts is newDataHashes (key to note: ZKP does not support private key of the receiver, the new key is visible for sender)
    ///         5. The newDataHashes identified ciphertexts are available in the storage: need the signature from the receiver signing oldDataHashes and newDataHashes
    /// @param proofs Proof generated by ZKP
    function verifyTransferValidity(
        bytes[] calldata proofs
    ) external view override returns (TransferValidityProofOutput[] memory) {
        TransferValidityProofOutput[]
            memory outputs = new TransferValidityProofOutput[](proofs.length);

       for (uint256 i = 0; i < proofs.length; i++) {
            // 144 bytes for oldDataHashes, newDataHashes, pubKey, sealedKey, TODO: proofs payload
            require(proofs[i].length == 144, "Invalid proof length");

            bytes32 oldHash = bytes32(proofs[i][0:32]);
            bytes32 newHash = bytes32(proofs[i][32:64]);
            bytes memory pubKey = proofs[i][64:128];
            bytes16 sealedKey = bytes16(proofs[i][128:144]);

            // TODO: verify the proofs
            // 1. verify ZKP proof
            // 2. verify receiver's signature

            outputs[i] = TransferValidityProofOutput(
                oldHash,
                newHash,
                pubKey,
                sealedKey,
                true
            );
        }

        return outputs;
    }
}
